## Creating the chat session management features ##

1.  **Understand the Goal:** The request is to build the foundation for chat sessions. This means storing session information (metadata) and the sequence of messages within each session. The actual LLM interaction is deferred. RAG context retrieval within the chat flow is also deferred but anticipated.

2.  **Identify Core Entities:**
    *   **Session:** Represents a single conversation thread. Needs a unique ID, potentially a name, timestamps, associated documents (for RAG context), the LLM model intended for use, and maybe some metadata/tags for searching sessions.
    *   **Message:** Represents a single turn in the conversation (user prompt or assistant response). Needs a unique ID (or sequence number within the session), a link to its session, the role ('user' or 'assistant'), the text content, and a timestamp.

3.  **Map Entities to Database Tables:** This was already done in Step 2 when we designed the `db/models.py`. We have:
    *   `sessions_table`: Matches the Session entity. Fields like `id`, `name`, `created_at`, `last_updated_at`, `llm_model_name`, `rag_document_ids`, `metadata_tags` are already defined.
    *   `chat_messages_table`: Matches the Message entity. Fields like `id` (auto-incrementing PK), `session_id` (FK to sessions), `timestamp`, `role`, `content`, `metadata`.

4.  **Design API Endpoints:** What operations are needed for sessions and messages?
    *   **Create Session:** `POST /api/v1/sessions/` - Takes optional name, RAG document IDs. Returns the new session's details.
    *   **List Sessions:** `GET /api/v1/sessions/` - Returns a list of sessions, potentially with pagination and filtering (defer complex filtering for now, just list recent ones).
    *   **Get Session Details:** `GET /api/v1/sessions/{session_id}` - Returns metadata for a specific session.
    *   **Delete Session:** `DELETE /api/v1/sessions/{session_id}` - Removes a session and its associated messages.
    *   **Add Message to Session:** `POST /api/v1/sessions/{session_id}/messages` - Takes the user's prompt (`role='user'`, `content`). Stores it. *Crucially, for now, it will just store the user message and maybe return a simple acknowledgement or the stored message details. The LLM response part is skipped.*
    *   **List Messages in Session:** `GET /api/v1/sessions/{session_id}/messages` - Returns all messages for a given session, ordered by timestamp.

5.  **Define API Request/Response Models (Pydantic):** Based on the endpoints and DB tables:
    *   `SessionCreateRequest`: `name` (optional), `rag_document_ids` (optional list of strings).
    *   `SessionMetadata`: Mirrors `sessions_table` fields for responses (`id`, `name`, `created_at`, `last_updated_at`, `llm_model_name`, `rag_document_ids`, `metadata_tags`).
    *   `ChatMessageCreateRequest`: `content` (required string), `role` (should probably default to 'user' or be validated).
    *   `ChatMessage`: Mirrors `chat_messages_table` fields for responses (`id`, `session_id`, `timestamp`, `role`, `content`, `metadata`).
    *   `SessionDetailResponse`: Could include `SessionMetadata` and potentially the first few/last few messages, or just the metadata. Let's start with just metadata.
    *   `SessionListResponse`: A list of `SessionMetadata`.
    *   `MessageListResponse`: A list of `ChatMessage`.
    *   `MessageCreateResponse`: Could return the created `ChatMessage`.

6.  **Implement API Logic (FastAPI Routers/Endpoints):**
    *   Create a new file: `app/api/endpoints/sessions.py`.
    *   Create an `APIRouter` instance.
    *   Implement each endpoint function defined in step 4.
    *   Use the Pydantic models for request validation and response formatting.
    *   Interact with the SQLite database using the `database` object and SQLAlchemy Core queries (`insert`, `select`, `delete`, `update`).
        *   **Create Session:** Generate UUID, insert into `sessions_table`.
        *   **List Sessions:** Select from `sessions_table`, order by `last_updated_at` or `created_at`, add pagination (`limit`, `offset`).
        *   **Get Session:** Select from `sessions_table` where `id` matches. Handle 404.
        *   **Delete Session:** Use a transaction. Delete from `chat_messages_table` where `session_id` matches, then delete from `sessions_table` where `id` matches. Handle 404. Return 204 No Content.
        *   **Add Message:** Generate timestamp, validate role (default to 'user'), insert into `chat_messages_table`. *Crucially*, update the `last_updated_at` timestamp on the parent `sessions_table` record. Handle 404 if session doesn't exist.
        *   **List Messages:** Select from `chat_messages_table` where `session_id` matches, order by `timestamp`. Handle 404.
    *   Use appropriate HTTP status codes (200, 201, 204, 404, 500).
    *   Add logging.

7.  **Integrate the Router:** Include the new sessions router in `app/main.py` similar to how the documents router was added.

8.  **Refinement and Considerations:**
    *   **UUIDs:** Use `uuid.uuid4()` for session IDs.
    *   **Timestamps:** Use `datetime.datetime.now(datetime.timezone.utc)` for consistency. Ensure the database stores timezone-aware datetimes (which `sqlalchemy.DateTime(timezone=True)` should handle with SQLite).
    *   **Updating `last_updated_at`:** This is important for sorting sessions. Do this whenever a message is added.
    *   **Transactions:** Use `async with database.transaction():` for operations involving multiple tables (like deleting a session and its messages) to ensure atomicity.
    *   **Error Handling:** Robust `try...except` blocks, especially around database operations. Check if sessions/messages exist before operating on them.
    *   **Dependencies:** Use the global `database` instance for simplicity for now. Consider FastAPI `Depends` later if needed.
    *   **LLM Model Placeholder:** Use `settings.DEFAULT_MODEL_NAME` when creating a session, even though we aren't calling it yet.
    *   **RAG Document IDs:** Validate that the provided `rag_document_ids` (if any) actually exist in the `documents` table? Maybe defer this check for simplicity initially, but good practice later.
    *   **Metadata Tags:** How are these generated? The request mentions *automatic* tagging. Defer this for now, just store `None` or an empty list/dict.

9.  **Code Structure:** Keep the structure clean: `app/api/endpoints/sessions.py` for the API, DB interactions use models from `db/models.py` and connection from `db/database.py`.

This detailed thinking process covers the database schema, API design, request/response models, implementation details, and integration.

## Enhance the `POST /api/v1/sessions/{session_id}/messages` endpoint. ##

**The goal is to add:**  

1.  **RAG Step:**
    *   Retrieve the `rag_document_ids` associated with the current session from the `sessions` table.
    *   If document IDs exist, perform a semantic search using the new user message as the query against the ChromaDB `documents` collection, filtering by those specific document IDs.
    *   Retrieve the top N relevant document chunks.
2.  **Context Formatting:**
    *   Format the retrieved RAG context (the text from the relevant chunks).
3.  **Prompt Construction:**
    *   Retrieve recent chat history from the `chat_messages` table for the current session.
    *   Construct a prompt for the LLM that includes:
        *   System instructions (optional).
        *   Formatted RAG context.
        *   Formatted recent chat history.
        *   The new user message.
4.  **Placeholder LLM Call:**
    *   Instead of calling a real LLM, simulate a response. This could be a simple canned message like "LLM response placeholder based on your query and context." or even echo back the constructed prompt or retrieved context.
5.  **Store Assistant Message:**
    *   Store the placeholder LLM response as a new message with `role='assistant'` in the `chat_messages` table, linked to the same session.
6.  **Return Response:**
    *   Decide what to return to the API client. Options:
        *   Just the assistant's response (`ChatMessageResponse`).
        *   Both the user's saved message and the assistant's response (`List[ChatMessageResponse]`).
        *   A custom response object containing the assistant message and maybe context info. Let's start by returning just the assistant's `ChatMessageResponse`.

**Refinement:**
*   How much chat history to include? Make it configurable or use a simple limit (e.g., last 5 turns).
*   How to format the prompt? Use a clear structure (e.g., markers for context, history, user query).
*   Where should the RAG logic live? It could be directly in the endpoint function for now, or moved to a dedicated `ChatService` later. Let's put it in the endpoint first for clarity.
*   Need access to the embedding function (`generate_embeddings`) and ChromaDB client within the endpoint.
*   Need access to the database (`database`) to fetch session info and chat history.

**Plan:**
1.  Modify the `add_message_to_session` function in `app/api/endpoints/sessions.py`.
2.  Import necessary functions/clients: `get_chroma_client`, `generate_embeddings`, `settings`, `sqlalchemy`, etc.
3.  Fetch session data (including `rag_document_ids`).
4.  Store the incoming user message first (within a transaction).
5.  Perform RAG Search:
    *   Check if `rag_document_ids` exist for the session.
    *   If yes, generate embedding for the user's message content.
    *   Query ChromaDB `documents` collection, filtering by session's `document_ids`.
    *   Handle results.
6.  Retrieve Chat History:
    *   Query `chat_messages` table for the session, limit results, order by timestamp.
7.  Format Context and History: Create strings representing the retrieved information.
8.  Construct the Prompt String (placeholder).
9.  Generate Placeholder LLM Response: Create a simple string.
10. Store Assistant Message: Insert the placeholder response into `chat_messages` table.
11. Update Session Timestamp: This should happen when the *assistant* message is added (or keep the user message add logic). Let's make sure it reflects the *end* of the interaction. The current transaction handles the user message insert + session update. We need another step for the assistant message. Maybe combine into one larger transaction? Or update timestamp again after assistant message? Let's update it again for simplicity.
12. Return the newly created assistant message object.

